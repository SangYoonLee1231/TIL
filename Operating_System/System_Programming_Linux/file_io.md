# 파일 I/O Part 1 (Linking, 파일 스트림과 디스크립터, 라이브러리 버퍼)

<br/>

> 참고 자료 : '시스템 프로그래밍' 학부 수업 자료

<br/><br/>

### 목차

- <a href="https://github.com/SangYoonLee1231/TIL/blob/main/Operating_System/System_Programming_Linux/file_io.md#%EC%82%AC%EC%A0%84-%EC%A7%80%EC%8B%9D">시전 지식</a>
- <a href="https://github.com/SangYoonLee1231/TIL/blob/main/Operating_System/System_Programming_Linux/file_io.md#%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EC%99%80-linking">라이브러리와 Linking</a>
- <a href="https://github.com/SangYoonLee1231/TIL/blob/main/Operating_System/System_Programming_Linux/file_io.md#%ED%8C%8C%EC%9D%BC-%EC%8A%A4%ED%8A%B8%EB%A6%BC-file--%ED%8C%8C%EC%9D%BC-%EB%94%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%84%B0-file-discriptor">파일 스트림 (FILE \*), 파일 디스크립터 (File Discriptor)</a>
- <a href="https://github.com/SangYoonLee1231/TIL/blob/main/Operating_System/System_Programming_Linux/file_io.md#%EC%A0%95%EB%A6%AC">정리</a>

<br/><br/>

### 사전 지식

- OS가 동작하는 공간 → **커널 스페이스**

- 시스템 콜을 하는 공간 → **유저 스페이스**(의 라이브러리)

- 시스템 콜이 실행되는 공간 → **커널 스페이스**

  - ex) open이라는 콜

- **Trap** : 유저 스페이스에서 커널로 들어갈 때 쓰는 명령 (= 소프트웨어 인터럽트)

  - 소프트웨어에 의해 강제로 인터럽트가 일어난다.

  - 프로그래머가 이미 심어놓은 코드 → 이미 인지되있는 명령어라는 점이 하드웨어 인터럽트와 다른 점
  - 하지만 CPU에게 이벤트가 일어났다고 해도 전달하는 방식은 소프트웨어 인터럽트나 하드웨어 인터럽트나 똑같다.

- 그 외 지식들

  - **IPC** = Inter Process Communication → 어떤 방법을 통해 독립된 프로세스들이 소통하는 지

  - **시그널** : 리눅스에서 프로세스에게 아주 간단한 방법으로 메세지를 보내 이벤트를 알림 (시그널 핸들링)

<br/><br/>

## 라이브러리와 Linking

- **라이브러리** : 컴파일된 객체(오브젝트)들 또는 오브젝트 안 여러 함수들을 모아둔 것

  - 모아놓는 이유 : 여러 프로젝트에 재활용하기 위해서

  - 리눅스 라이브러리는 보통 /lib 나 /usr/lib 두 디렉토리에 있다.
    - (/lib에서 /은 루트 디렉토리, 파일 시스템의 제일 꼭대기)

- 어떤 프로그램을 만들려고 하면, 라이브러리 함수(ex: printf, scanf 등)들을 콜해서 쓰면 된다.

  - 그럴러면 라이브러리 함수들과 내 프로그램을 함께 묶어야 한다.

  - 이것을 **Linking (묶는다)** 이라 한다.

  - 프로그램의 컴파일 과정을 살펴보자.

    - 소스를 만들면, 각 소스별로 컴파일 → 개별 오브젝트 파일 생성

      → 그것들을 하나로 연결해야 하나의 실행 파일이 만들어진다.

    - 내가 만든 오브젝트 뿐만 아니라, 내가 사용한 라이브러리에 들어있는 함수들도 추출해서 하나의 묶음으로 실행 파일이 만들어진다.

  - 이 때 중요한 건, 모든 데이터나 코드가 한 파일에 들어있다는 것이다.

  - 이보다 더 중요한 것은, 모든 개별 함수들은 묶일 때 프로그램 내에서 순서가 매겨진 채로 묶이기 때문에 주소가 다시 새로 배정된다.

  - 이를 **Address Binding**이라 한다. (linking의 다른 말)

    - 주소를 연결해 준다.

    - Linking 시 라이브러리 함수들에게 주소가 새로 배정된다.

<br/>

### 링크를 하는 방법 2가지

1. **Static Linking**

   - 내 실행 파일에 내가 원하는 모든 오브젝트를 나의 몸체에 갖다 붙이는 방법

     - (모든 게 다 내 몸 안에 완성된 상태로 붙는다)

   - 컴파일 시, 라이브러리의 코드가 실행 파일에 직접 포함된다.

   - 메모리 관리 측면에서 비효율적 - 같은 함수(코드)가 중복된다

   - 확장자는 보통 `.a`다.

2. **Dynamic Linking (Shared Library)**

   - 라이브러리 함수들을 각자 붙이지 말고, 시스템이 한 걸 어디에 둘 테니까 필요하면 같이 공유해서 쓰자.

   - 각 프로그램은 OS에게 도움을 요청해서 라이브러리와 자신을 연결해야 한다.

     → **Dynamic Linking** (실제 필요한 그 시점에서 찾아가 연결)

   - OS마다 부르는 명칭

     - 리눅스 - Shared Library (`.so`)

     - 윈도우 - Dynamic Linking Library (DLL)

   - OS 커널 영역에 Dynamic Linking을 위한 **심볼 테이블**이 있다.

     - 라이브러리가 현재 위치해있는 라이브러리의 이름과 현재 위치해있는 주소가 심볼 테이블에 저장된다.

     - 여기서 위치에 해당하는 라벨이 심볼이다.

   - 이렇게 하면, 동일한 라이브러리의 코드를 여러 실행 파일이 함께 공유할 수 있어 메모리 사용량, 실행 파일 크기 감소라는 이점을 얻을 수 있다.

   - 단, 실행 파일이 해당 라이브러리에 종속적이게 되므로, 이식성이 떨어진다는 단점 또한 존재한다.

<br/><br/>

## 파일 스트림 (FILE \*), 파일 디스크립터 (File Discriptor)

- 파일과 관련하여 2가지 측면에서 살펴볼 것

  - **<1>** stdio 라이브러리에서 제공하는 파일과 관련된 함수들

    - **File Stream (FILE \*)** : 그 파일과 관련된 모든 정보를 갖고 있는 구조체

    - **표준 입력**, **표준 출력**, **표준 에러** : 이미 만들어져 있는 스트림

      - 이 세 가지는 자동으로 만들어진다.

    - 파일 스트림 구조체는 **라이브러리 콜을 통해서만 만들어진다.**

    - 리눅스는 모든 프로그램을 쉘(Shell)에서 실행한다.

      - 그리고 프로그램을 실행할 때, 쉘이 갖고 있던 여러 파일들의 속성이 응용 프로그램에 그대로 전달된다. → 상속된다.

      - 실행되고 있는 응용 프로그램은 실제로 쉘이 이미 만들어 놓은 (표준 입출력 장치에 대한) 파일 스트림을 그대로 가져다 쓰는 것이다.

    <br/>

  - **<2>** OS가 제공하는 File I/O 시스템 콜

    - OS 시스템 콜은 파일 스트림을 사용하지 않는다.

    - OS에서는 시스템 콜을 할 때 ‘**파일 디스크립터 (File Discriptor)**’라는 개념을 쓴다.

    - 파일 디스크립터는 쉽게 말해 **번호**, **첨자**이다.

    - **파일 디스크립터 테이블 (FDT)** : 프로그램이 실행될 때 생성되는 중요한 파일 구조체

      - 각 파일들에 대한 파일 정보나 장치 정보를 가리키고 있는 테이블

    ***

    \<FDT><br/>
    0 [ ] → 키보드 (표준 입력 장치)<br/>
    1 [ ] → 모니터 (표준 출력 장치)<br/>
    2 [ ] → 모니터 (표준 에러)<br/>
    . [ . ]<br/>
    . [ . ]<br/>
    . [ . ]<br/>

    ***

<br/>

- 1부터 순서대로 탐색했을 때 사용 되는 않는 번호는, 내가 생성하려는 파일의 디스크립터 번호로 할당된다.

  - 중간에 3번을 close → 3번은 미사용 상태가 됨

  - 그 다음 파일을 오픈하면 파일 디스크립터로 **3번이 할당됨**

<br/>

- 일반적으로 리눅스에서는 한 프로세스당 최대 1024개까지 파일을 열 수 있다고 한다.

<br/>

- Standard I/O Library 함수 (`printf`, `fprintf`, `puts`) 는 궁극적으로 ‘**시스템 콜**’의 도움을 받아야 한다.

  - 본인 함수가 OS에 들어갈 방법은 없으므로

  - `printf`, `fprintf`, `puts` 함수들의 소스 코드의 끝단에는 <strong>`write()`</strong>라는 OS 시스템 콜을 부르고 있다.

  <br/>

  - 시스템 콜을 바로 쓰지 않고 굳이 standard I/O library 함수를 사용하는 이유?

    - 라이브러리가 사용자에게 **편리성을 제공헤주기 때문이다.**

      - 더 풍부한 기능을 제공해준다.

    - 라이브러리가 제공하는 **Library Buffer**를 활용할 수 있다.

      - 라이브러리 함수를 호출할 때, 라이브러리에 버퍼(Buffer)를 두어, 커널에서 올라오는 데이터를 버퍼에 임시로 저장한 후 이를 반복적으로 활용할 수 있다. (시스템 콜 반복 호출을 방지하는 효과)

        - 버퍼(Buffer) = 캐시(Cache)

<br/><br/>

## 정리

- 라이브러리에서 사용하는 파일 객체 : **File Stream (FILE \*)**

  - 파일과 관련된 모든 정보를 갖고 있는 구조체이다.

  - 파일에서 데이터를 읽고 쓰는 데 사용되는 입출력(I/O) 스트림이다.

<br/>

- 시스템 콜에서 제공하는 파일에 대한 정보는 **파일 디스크립터 (File Discriptor)**를 가지고 관리한다.

- **파일 스트림 하나와 파일 디스크립터 번호 하나는 일대일로 대응한다.**

  - **파일 하나를 열면, 파일 라이브러리에서는 스트림 객체를 하나 만들 것이고, 시스템 콜에는 그에 해당하는 디스크립터 번호를 하나 배정해야 한다.**

- 파일 스트림에는 자기 스트림에 대응하는 디스크립터 번호를 하나 기록하고 있어야 한다.

<br/><br/>

> ### ☝🏻 Q. 파일 디스크립터가 파일 스트림과 어떻게 함께 사용되는지 구체적으로 설명해주세요.
>
> 파일 디스크립터(file descriptor)는 파일을 조작할 때 사용되는 정수형 값으로, 일반적으로 파일 스트림과 함께 사용됩니다. 파일 스트림은 파일에서 데이터를 읽고 쓰는 데 사용되는 입출력(I/O) 스트림입니다.
>
> 파일을 열 때, 운영 체제는 파일 디스크립터를 할당하고, 이 파일 디스크립터를 사용하여 파일을 조작할 수 있게 됩니다. 예를 들어, 파일을 읽기 위해 파일 디스크립터를 사용하는 코드는 다음과 같을 수 있습니다.
>
> ```c
> int fd = open("myfile.txt", O_RDONLY);
> char buffer[1024];
> ssize_t nread = read(fd, buffer, sizeof(buffer));
> ```
>
> 위 코드에서 open() 함수는 "myfile.txt"라는 파일을 열고, 이 파일에 대한 파일 디스크립터를 반환합니다. read() 함수는 파일 디스크립터를 사용하여 파일에서 데이터를 읽고, buffer 배열에 저장합니다.
>
> 또한, 파일을 쓰기 위해 파일 디스크립터를 사용하는 코드는 다음과 같을 수 있습니다.
>
> ```c
> int fd = open("myfile.txt", O_WRONLY);
> char *data = "Hello, world!";
> write(fd, data, strlen(data));
> ```
>
> 위 코드에서 open() 함수는 "myfile.txt"라는 파일을 열고, 이 파일에 대한 파일 디스크립터를 반환합니다. write() 함수는 파일 디스크립터를 사용하여 파일에 데이터를 쓰게 됩니다.
>
> 이렇게 파일 디스크립터는 파일 스트림과 함께 사용되어 파일을 조작하는 데 필요한 정보를 제공합니다. 파일 스트림은 실제 입출력 작업을 수행하고, 파일 디스크립터는 해당 파일에 대한 식별자를 제공합니다.

<br/>

👉 <a href="https://github.com/SangYoonLee1231/TIL/blob/main/Operating_System/System_Programming_Linux/file_io_pt2.md">Part 2</a>에서 이어집니다.

<br/>
